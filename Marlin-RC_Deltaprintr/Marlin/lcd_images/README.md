Generate arrays with

http://www.digole.com/tools/PicturetoC_Hex_converter.php

and put them in dogm_bitmaps.h

Be aware that the converter aligns the image width to bytes, thus
setting all (image_byte_width * 8 - image_pixel_width % 8) pixels on the
right hand side instead of leaving them blank.
Therefore, if the pixel width of an image is not a multiple of 8, the
output of the converter needs to be polished by hand. In particular, the
substraction of a certain value from the last generated byte in each row
is necessary.

Example:

```
    source image:       fsr0.png

    image_pixel_width:        17
    image_byte_width:          3

    generator output:

        0x00,0x00,0x7f
        ,0x00,0x00,0x7f
        ,0x20,0x82,0x7f
        ,0x20,0x82,0x7f
        ,0x20,0x82,0x7f
        ,0x20,0x82,0x7f
        ,0x20,0x82,0x7f
        ,0x20,0x82,0x7f
        ,0x20,0x82,0x7f
        ,0xaa,0xaa,0xff
        ,0x71,0xc7,0x7f
        ,0x20,0x82,0x7f
        ,0x00,0x00,0x7f
        ,0xff,0xff,0xff
        ,0xff,0xff,0xff

    alignment calculation:
        (image byte width * 8 - image pixel width % 8) = 7

    -> The generated array would display with a 7 pixels wide vertical
       bar on the right hand side.

    solution:

       The bytes in the array represent the pixels bit by bit in LSB0
       order.

       Thus, the image must be corrected by substracting 0x7F from the
       last byte in each row.
       (2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0 = 127 = 0x7F)

    final array for dogm_bitmaps.h (also cosmetically enhanced):

        0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
        0x20, 0x82, 0x00,
        0x20, 0x82, 0x00,
        0x20, 0x82, 0x00,
        0x20, 0x82, 0x00,
        0x20, 0x82, 0x00,
        0x20, 0x82, 0x00,
        0x20, 0x82, 0x00,
        0xAA, 0xAA, 0x80,
        0x71, 0xC7, 0x00,
        0x20, 0x82, 0x00,
        0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x80,
        0xFF, 0xFF, 0x80
```
